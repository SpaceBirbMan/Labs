#include <iostream>
#include <vector>
#include "Lib.h"

using namespace Mtrx;

int main()
{
	std::cout.precision(2);

	int n = 2;

	std::cin >> n;

	Matrix F(n, n+1);
	Matrix M(n);
	F.randomize_advanced(-10, 10); //заполнение
	F.print();
	
	unsigned int k = 1;
	unsigned int km = 0;

	///Гаусс

	for (k; k <= n; k++) //прямой ход
	{
		km = k - 1;
		if (abs(F(km,km)) < 0.000001)
		{
			for (int i = 0; i < km - 1; i++)
				if (F.M[i][km] != 0)
				{
					M = F(i,km);
					F.M[i][km] = F(km,km);
					F.M[km][km] = *M.A;
					F.print();
				}
		}

		for (int i = km; i < n - 1; i++) 
			for (int j = km; j < km; j++)
			{
				F.M[i][j] = (F.M[i][j] * F.M[km][km] - F.M[km][j] * F.M[i][km]) / F.M[km][km];
			}
		F.print();

		for (int i = km+1; i < n; i++) //зануление
			F.M[i][km] = 0;
		F.print();

		for (int i = n; i >= 0; i--) //деление на ведущий элемент
		{
			if (F.M[km][km] != 0)
				F.M[km][i] = F.M[km][i] / F.M[km][km];
			else abort;
		}
		F.print();
	}

	float* x = new float[n];

	std::cout << std::endl;

	float y = 0;

	for (int a = n - 1; a >= 0; a--) //обратный ход
	{
		if (a == n - 1)
			x[a] = F(a,n);
		else
		{
			x[a] = F.M[a][n];
			for (int b = n - 1; b >= a + 1; b--)
			{
				//std::cout << x[a] << " " << x[b] << " " << F.M[a][b] << "\n";
				x[a] = x[a] - x[b] * F.M[a][b];
			}
		}
	}

	for (int r = 0; r < n; r++)
	{
		std::cout << "x" << r + 1 << " " << x[r] << std::endl;
	}

	///Гаусс - Жордан
	/*
	
	Алгоритм Жордана-Гаусса, также известный как метод исключения Гаусса-Жордана, является одним из методов решения систем линейных уравнений. Вот его общая процедура:

	1. Начните с расширенной матрицы системы уравнений, состоящей из коэффициентов уравнений и столбца свободных членов.
	2. Если необходимо, выполните операции перестановки строк, чтобы обеспечить наличие ненулевых элементов на главной диагонали матрицы.
	3. Для каждого столбца, начиная с первого, выполните следующие операции:
	   - Разделите текущую строку на значение элемента на главной диагонали текущего столбца. Это приведет к получению "единичного" элемента в позиции диагонали.
	   - Для каждой строки, отличной от текущей, вычтите из нее кратное текущей строки так, чтобы элемент под главной диагональю данного столбца стал равным нулю.
	4. Повторите шаг 3 для каждого следующего столбца, за исключением последнего.
	5. Получив матрицу, находящуюся в улучшенном ступенчатом виде, приведите ее к улучшенному каноническому виду, сделав все элементы выше каждого главного диагонального элемента равными нулю.
	6. Считайте решением системы уравнений компоненты последнего столбца полученной матрицы.

	Это общая схема алгоритма. Реализация может варьироваться в зависимости от выбранного языка программирования и используемой библиотеки для работы с матрицами.
	
	*/


}
